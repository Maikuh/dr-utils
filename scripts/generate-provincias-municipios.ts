import path from "node:path"

type Row = {
  Municipio: string
  Provincia: string
}

/* ---------------------------------- */
/* Utilities                          */
/* ---------------------------------- */

function normalizeKey(value: string): string {
  return value
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^A-Za-z0-9]+/g, '_')
    .replace(/^_|_$/g, '')
    .toUpperCase()
}

function fatal(message: string): never {
  console.error(`❌ ${message}`)
  process.exit(1)
}

function stripInvisible(value: string): string {
  return value
    // BOM
    .replace(/\uFEFF/g, '')
    // Zero-width & directional marks
    .replace(/[\u200B-\u200F\u202A-\u202E]/g, '')
    // Non-breaking space → normal space
    .replace(/\u00A0/g, ' ')
    // Other control chars except \n \r \t
    .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, '')
    .trim();
}

/* ---------------------------------- */
/* CSV Parsing                        */
/* ---------------------------------- */

function parseCSV(csv: string): Row[] {
  const lines = stripInvisible(csv).trim().split(/\r?\n/)

  if (lines.length < 2) {
    fatal('CSV must contain a header and at least one data row')
  }

  const header = lines[0].split(',').map(h => h.trim())
  if (header[0] !== 'Municipio' || header[1] !== 'Provincia') {
    fatal(`Invalid CSV header. Expected: Municipio,Provincia`)
  }

  return lines.slice(1).map((line, index) => {
    const parts = line.split(',').map(v => v.trim())

    if (parts.length !== 2) {
      fatal(`Invalid column count on line ${index + 2}`)
    }

    const [Municipio, Provincia] = parts

    if (!Municipio || !Provincia) {
      fatal(`Empty value on line ${index + 2}`)
    }

    return { Municipio, Provincia }
  })
}

/* ---------------------------------- */
/* Load & Validate                    */
/* ---------------------------------- */

const csv = await Bun.file(path.resolve('assets/municipios-por-provincia.csv')).text()
const rows = parseCSV(csv)

const provinciasMap = new Map<string, Set<string>>()
const municipioToProvincia = new Map<string, string>()

for (const { Municipio, Provincia } of rows) {
  // Deduplicate & validate conflicting mappings
  const existingProvincia = municipioToProvincia.get(Municipio)
  if (existingProvincia && existingProvincia !== Provincia) {
    fatal(
      `Municipio "${Municipio}" appears under multiple provincias: ` +
      `"${existingProvincia}" and "${Provincia}"`
    )
  }

  municipioToProvincia.set(Municipio, Provincia)

  if (!provinciasMap.has(Provincia)) {
    provinciasMap.set(Provincia, new Set())
  }

  provinciasMap.get(Provincia)!.add(Municipio)
}

/* ---------------------------------- */
/* Sort                               */
/* ---------------------------------- */

const sortedProvincias = [...provinciasMap.keys()].sort((a, b) =>
  a.localeCompare(b, 'es')
)

for (const set of provinciasMap.values()) {
  const sorted = [...set].sort((a, b) => a.localeCompare(b, 'es'))
  set.clear()
  sorted.forEach(v => set.add(v))
}

/* ---------------------------------- */
/* Code Generation                    */
/* ---------------------------------- */

const provinciaEnum = sortedProvincias
  .map(p => `  ${normalizeKey(p)}: '${p}',`)
  .join('\n')

const municipiosPorProvincia = sortedProvincias
  .map(p => {
    const key = normalizeKey(p)
    const municipios = [...provinciasMap.get(p)!]
      .map(m => `    '${m}',`)
      .join('\n')

    return `  [Provincias.${key}]: [\n${municipios}\n  ],`
  })
  .join('\n')

const provinciaPorMunicipio = [...municipioToProvincia.entries()]
  .sort((a, b) => a[0].localeCompare(b[0], 'es'))
  .map(([m, p]) => `  ${m.includes(' ') ? `'${m}'` : m}: Provincias.${normalizeKey(p)},`)
  .join('\n')

const generatedHeader = `/* AUTO-GENERATED FILE — DO NOT EDIT*/
/* Generated by scripts/generate-provincias-municipios.ts*/`

const provinciasConst = `${generatedHeader}

export const Provincias = {
${provinciaEnum}
} as const
`

const municipiosPorProvinciaOutput = `${generatedHeader}

import { Provincias } from './provincias.constant'

export const MunicipiosPorProvincia = {
${municipiosPorProvincia}
} as const
`

const provinciaPorMunicipioOutput = `${generatedHeader}

import { Municipio, Provincia } from '@/types/municipio-provincia.type'
import { Provincias } from './provincias.constant'

export const ProvinciaPorMunicipio: Record<Municipio, Provincia> = {
${provinciaPorMunicipio}
}
`

const typesOutput = `${generatedHeader}

import { MunicipiosPorProvincia } from '@/constants/municipios-por-provincia.constant'
import { Provincias } from '@/constants/provincias.constant'

export type Provincia = (typeof Provincias)[keyof typeof Provincias]

export type Municipio = (typeof MunicipiosPorProvincia)[keyof typeof MunicipiosPorProvincia][number]
`

const utilsOutput = `${generatedHeader}

import { MunicipiosPorProvincia } from '@/constants/municipios-por-provincia.constant'
import { ProvinciaPorMunicipio } from '@/constants/provincia-por-municipio.constant'
import { Municipio, Provincia } from '@/types/municipio-provincia.type'

export function getMunicipiosByProvincia(provincia: Provincia): readonly Municipio[] {
	return MunicipiosPorProvincia[provincia]
}

export function getProvinciaByMunicipio(municipio: Municipio): Provincia {
	return ProvinciaPorMunicipio[municipio]
}
`

await Promise.all([
    Bun.write(path.resolve('src/constants/provincias.constant.ts'), provinciasConst),
    Bun.write(path.resolve('src/constants/municipios-por-provincia.constant.ts'), municipiosPorProvinciaOutput),
    Bun.write(path.resolve('src/constants/provincia-por-municipio.constant.ts'), provinciaPorMunicipioOutput),
    Bun.write(path.resolve('src/types/municipio-provincia.type.ts'), typesOutput),
    Bun.write(path.resolve('src/utils/municipios-provincias.util.ts'), utilsOutput)
])

console.log("✅ generated files successfully")
